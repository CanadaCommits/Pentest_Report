\chapter{Attachments}
\section{Attachment 1}
\label{sec:attachment1}
\hfill\break
        \begin{lstlisting}[language=python]
./pycdc /home/kali/Schreibtisch/todecompile.pyc
# Source Generated with Decompyle++
# File: todecompile.pyc (Python 3.9)
Unsupported opcode: JUMP_IF_NOT_EXC_MATCH import sys
import json
import subprocess
import hashlib
from cryptography.fernet import Fernet
key = b'dGH1BR5gJ6wz6rne0kvmW50UsgY_J3KBZlRIUmsSOYw='
fernet Fernet(key)
def filter_cpuinfo(data):
    data = data.decode('ascii')
    data = data.split('\n')
    data = (lambda .0: [ line for line in .0 if 'cpu MHz' not in line ])(data) data = (lambda .0: [ line for line in .0 if 'bogomips' not in line ])(data) data = '\n'.join(data)
    return data.encode('ascii')
    data_filters = {
    'filter_cpuinfo': filter_cpuinfo }
    def derive_password (configuration):
    Unsupported opcode: WITH_EXCEPT_START
    input_data = bytearray.fromhex('30b6a9aec9927ae4f718217ddee3453789847be071bb536cf14cf71d257ef09a')
    # WARNING: Decompyle incomplete
def open_luks_device(configuration, password):
    if configuration.get('debug'):
        print(f'''Opening LUKS device using password: {password}''')
    cmd = [
    'cryptsetup',
    'LuksOpen',
    configuration['source_dev'],
    configuration['mapper_name']]
    subprocess.check_output(cmd, f'''{password}\n'''.encode('ascii'), **('input',))
    def close_luks_device(configuration):
    if configuration.get('debug'):
        print('Closing LUKS device.')
    cmd = [
    'cryptsetup',
    'luksClose',
    configuration['mapper_name']]
    subprocess.check_call(cmd)
def add_luks_passphrase (configuration, old_password, new_password):
    if configuration.get('debug'):
        print(f'''Adding passphrase: {new_password} (using existing     passphrase: {old_password})''')
    cmd = [
    'cryptsetup',
    'LuksAddKey',
    '--batch-mode',
    '--pbkdf-pbkdf2',
    '--pbkdf-force-iterations=1000', configuration['source_dev']]
    subprocess.check_output(cmd, f'''{old_password}\n{new_password}\n'''.encode('ascii'), **('input',))
def remove_luks_passphrase(configuration, old_password, new_password):
    if configuration.get('debug');
    print(f'''Removing old passphrase: {old_password} (remaining passphrase: {new_password}''')
    cmd = [
    'cryptsetup',
    'LuksRemovekey',
    '--batch-mode',
        configuration['source_dev']]
    subprocess.check_output(cmd, f'''{old_password}\n{new_password}\n'''.encode('ascii'), **('input',)) configuration = None
encrypted_configuration = b'gAAAAABj6U1FMZKAOONUKUE5IWJFYrY8jeRSfl2TqYpqfIiTrTP8ceGBoffIZt7XvWS5pXWE9afjswEi_f Sq9D-tc Enh8QflWQu2j4l58VrbjbD1s8kWRqcv6p65XHDiFSEDPAL1ybZD5BslOpzBWI59wWVL-plUJz8FuIIpf01PWdq4sLcB3bSK pfSrT-CkurhXFzqpRPEaTovsW8QLKpCsQuxYjrMTQ0yE7bwAkAUhBJrxt7TIBfZQPpsqCbt5Emrpb6eiudBNgI_F5V1KoRdG8WbEie-i1ix-XMcqZu-RhKDkUjw70GT-TaAdb5Y_cd0YMPmr4vnnf9t6nD1LzK3K86MuC_2JDRq0Voz1XbqeM-yxIgipC5rJAs40kuBdNcFImJW2UJLF'

if configuration is not None:
    encrypted_configuration = fernet.encrypt(json.dumps (configuration).encode())
        \end{lstlisting}

\newpage
\hfill\break

\section{Attachment 2}
\label{sec:attachment2}
\hfill\break

\begin{lstlisting}[language=python]
    #!/usr/bin/python3
import subprocess
import os
import time
import json
import sys

config = {
"openssl":      "/usr/bin/openssl",
"port":         20321,
"certfile":     "server.crt",
"keyfile":      "server.key",
}
if len(sys.argv) > 1:
config.update(json.loads(sys.argv[1]))

class ShellServer():
def __init__(self):
    self._proc = None
    self._client_cert = None
    self._cmds = False

def _process_line(self, line):
    line = line.rstrip("\r\n")
    if line.startswith("subject=") and self._client_cert is None:
        self._client_cert = line
    elif (not self._cmds) and (line.startswith("Secure Renegotiation")):
        # Commands are now active!
        self._cmds = True
        if self._client_cert == "subject=CN = Management Client Certificate, O = Secure Systems Inc., OU = admin=false":
            print("Non admin user logged in")
            print("System information granted to visitor!", file = self._proc.stdin)
            print("======================================", file = self._proc.stdin)
            print(file = self._proc.stdin)
            with open("/proc/meminfo") as f:
                print(f.read(), file = self._proc.stdin)
            print()
            print("Goodbye!")
            self._proc.stdin.flush()
            time.sleep(0.3)
            self._proc.kill()
        elif self._client_cert == "subject=CN = Management Client Certificate, O = Secure Systems Inc., OU = admin=true":
            print("Admin user logged in")
            print("Administrator access granted.", file = self._proc.stdin)
        else:
            print("Invalid certificate found")
            print("Error: your client certificate is invalid", file = self._proc.stdin)
            self._proc.stdin.flush()
            time.sleep(0.3)
            self._proc.kill()
    elif self._cmds:
        print("Executing: %s" % (line))
        self._proc.stdin.flush()
        cmd = subprocess.run(line, shell = True, capture_output = True)
        print(cmd.stdout.decode(), file = self._proc.stdin)
        self._proc.stdin.flush()

def run(self):
    self._proc = subprocess.Popen([ config["openssl"], "s_server", "-accept", str(config["port"]), "-cert", config["certfile"], "-key", config["keyfile"], "-naccept", "1", "-Verify", "1" ], stdout = subprocess.PIPE, stdin = subprocess.PIPE, bufsize = 0, universal_newlines = True)
    try:
        while True:
            try:
                self._proc.wait(0)
                break
            except subprocess.TimeoutExpired:
                # Still alive
                pass
            data = self._proc.stdout.readline()
            self._process_line(data)
            if len(data) == 0:
                time.sleep(0.1)
            else:
                print(data)
    except BrokenPipeError:
        pass

shs = ShellServer().run()
\end{lstlisting}
